<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Hello OpenCV.js</title>
</head>
<body>
  <h2>Hello OpenCV.js</h2>
  <p id="status">OpenCV.js is loading...</p>
  <div>
    <div class="inputoutput">
      <video id="videosrc" controls playsinline muted autoplay></video>
      <div class="caption">imageSrc <input type="file" id="fileInput" name="file" /></div>
    </div>
    <div class="inputoutput">
      <canvas id="canvasOutput" ></canvas>
      <div class="caption">canvasOutput</div>
    </div>
  </div>
<script type="text/javascript">
let outputCanvas = document.getElementById("canvasOutput");

window.addEventListener("load", function(){
  let videoElement = document.getElementById('videosrc');

  const constraints = {
    video: true
  }
  // スマホのカメラを使用する
  navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
      videoElement.srcObject = stream;
      videoElement.addEventListener("canplay", onVideoCanPlay, false);
  })

  function onVideoCanPlay(){
    videoElement.width = videoElement.videoWidth;
    videoElement.height = videoElement.videoHeight;
    setTimeout(processVideo, 0);;
  }
  let cap = null;

  // parameters for ShiTomasi corner detection
  let [maxCorners, qualityLevel, minDistance, blockSize] = [3, 0.3, 7, 7];

  // parameters for lucas kanade optical flow
  let winSize = new cv.Size(15, 15);
  let maxLevel = 2;
  let criteria = new cv.TermCriteria(cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, 10, 0.03);

  // create some random colors
  let color = [];
  for (let i = 0; i < maxCorners; i++) {
      color.push(new cv.Scalar(parseInt(Math.random()*255), parseInt(Math.random()*255),
                              parseInt(Math.random()*255), 255));
  }

  // take first frame and find corners in it
  let oldFrame;
  let oldGray = new cv.Mat();

  let p0 = null;
  let none = new cv.Mat();

  let features = false;
  outputCanvas.addEventListener("click", function(event){
      let click_x = event.pageX;
      let click_y = event.pageY;

      let client_rect = this.getBoundingClientRect();
      let position_x = client_rect.left + window.pageXOffset;
      let position_y = client_rect.top + window.pageYOffset;

      let x = click_x - position_x;
      let y = click_y - position_y;
      p0 = new cv.Mat(1, 1, cv.CV_32FC2);
      p0.data32F[0] = x;
      p0.data32F[1] = y;
  })

  // Create a mask image for drawing purposes
  let zeroEle = new cv.Scalar(0, 0, 0, 255);
  let mask;

  let frame;
  let frameGray = new cv.Mat();
  let p1 = new cv.Mat();
  let st = new cv.Mat();
  let err = new cv.Mat();
  let streaming = true;

  const FPS = 60;
  function processVideo() {
      try {
          if (!streaming) {
              // clean and stop.
              frame.delete(); oldGray.delete(); p0.delete(); p1.delete(); err.delete(); mask.delete();
              return;
          }
          if(cap == null){
            oldFrame = new cv.Mat(videoElement.videoHeight, videoElement.videoWidth, cv.CV_8UC4);
            cap = new cv.VideoCapture(videoElement);
            cap.read(oldFrame);
            // oldFrameをグレースケール化してoldGrayに格納
            cv.cvtColor(oldFrame, oldGray, cv.COLOR_RGB2GRAY);
            mask = new cv.Mat(oldFrame.rows, oldFrame.cols, oldFrame.type(), zeroEle);
            frame = new cv.Mat(videoElement.height, videoElement.width, cv.CV_8UC4);
          }
          let begin = Date.now();

          // start processing.
          cap.read(frame);
          cv.cvtColor(frame, frameGray, cv.COLOR_RGBA2GRAY);

          // calculate optical flow
          if(p0 != null){
              cv.calcOpticalFlowPyrLK(oldGray, frameGray, p0, p1, st, err, winSize, maxLevel, criteria);
              // select good points
              let goodNew = [];
              let goodOld = [];
              for (let i = 0; i < st.rows; i++) {
                  if (st.data[i] === 1) {
                      goodNew.push(new cv.Point(p1.data32F[i*2], p1.data32F[i*2+1]));
                      goodOld.push(new cv.Point(p0.data32F[i*2], p0.data32F[i*2+1]));
                  }
              }

              // draw the tracks
              for (let i = 0; i < goodNew.length; i++) {
                  cv.line(mask, goodNew[i], goodOld[i], color[i], 2);
                  cv.circle(frame, goodNew[i], 5, color[i], -1);
              }
              cv.add(frame, mask, frame);

              cv.imshow('canvasOutput', frame);
              
              // now update the previous frame and previous points
              frameGray.copyTo(oldGray);
              p0.delete(); p0 = null;
              p0 = new cv.Mat(goodNew.length, 1, cv.CV_32FC2);
              for (let i = 0; i < goodNew.length; i++) {
                  p0.data32F[i*2] = goodNew[i].x;
                  p0.data32F[i*2+1] = goodNew[i].y;
              }
          }else{
              cv.imshow('canvasOutput', frame);
          }
          // schedule the next one.
          let delay = 1000/FPS - (Date.now() - begin);
          setTimeout(processVideo, delay);
      } catch (err) {
          // utils.printError(err);
          console.log(err)
          console.error("error is occured");
      }
  };
  
  // schedule the first one.
  // setTimeout(processVideo, 0);
});

var Module = {
  // https://emscripten.org/docs/api_reference/module.html#Module.onRuntimeInitialized
  onRuntimeInitialized() {
    document.getElementById('status').innerHTML = 'OpenCV.js is ready.';
  }
};

</script>
<script async src="opencv.js" type="text/javascript"></script>
</body>
</html>